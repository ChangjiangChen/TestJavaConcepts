>String是不可变的
String是不可变的（immutable），不变性的体现是：String类内部通过char数组来保存字符串，而这个char数组被声明为：final。那么为什么要将String类声明为不可变呢？了解设计模式的你应该知道有一种模式叫做“不变模式”（immutable pattern），String类的设计就是使用了不变模式，有兴趣的朋友可以看看“不变模式”讲的具体是啥东东。
说完String的不可变性，需要说说String的“final性”（其实也还是不可变性决定的）。这也是有些面试官会问到的问题：我能不能写一个类继承自String？为什么？我们来看看String类的声明：
public final class String implements java.io.Serializable, Comparable<String>, CharSequence

>运行时数据区
要深入理解String必须先了解Java内存机制——运行时数据区（Runtime Data Area）。《The JavaTM Virtual Machine Specification》中将运行时数据区分为六部分（参看第三章）： 1）The pc Register；2）Java Virtual Machine Stacks；3）Heap；4）Method Area；5）Runtime Constant Pool；6）Native Method Stacks；     以上数据区的具体描述可参考规范。需要注意的是，以上只是一个规范说明，并没有规定虚拟机如何实现这些数据区。
在说明String对象存储机制之前，我们需要先了解数据区的三个部分：Java 虚拟机栈（可以简称为Java栈）、堆和运行时常量池（简称常量池）。对于Java栈和堆大家应该比较熟悉，这里有一个关键点是常量池，下面就重点介绍一下与String相关的常量池

>常量池
虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用常量的一个有序集合，包括直接常量（string,integer和floating point常量）和对其他类型、字段和方法的符号引用。池中的数据项就像数组一样是通过索引访问的。因为常量池存储了相应类型所用到的所有类型、字段和方法的符号引用，所以它在Java程序的动态链接中起着核心的作用。

1）true
要说明一点：当两个字符串字面值连接时（相加），得到的新字符串依然是字符串字面值，保存在常量池中。
2）false
当字符串字面值与String类型变量连接时，得到的新字符串不再保存在常量池中，而是在堆中新建一个String对象来存放。很明显常量池中要求的存放的是常量，有String类型变量当然不能存在常量池中了。
3）true
注意此题与上一题的区别，此处是字符串字面值与String类型常量连接，得到的新字符串依然保存在常量池中。
4）false
此题中第条语句：final String bb = getBB();其实与final String bb = new String(“b”);是一样的。也就是说return “b”会在堆中创建一个String对象保存”b”，虽然bb被定义成了final。可见并非定义为final的就保存在常量池中，很明显此处bb常量引用的String对象保存在堆中，因为getBB()得到的String已经保存在堆中了，final的String引用并不会改变String已经保存在堆中这个事实。
5）false,true
可能很多人对intern()这个函数不了解。JDK API文档中对intern()方法的描述是：
返回字符串对象的规范化表示形式。
一个初始为空的字符串池，它由类 String 私有地维护。
当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。
它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。
所有字面值字符串和字符串赋值常量表达式都使用 intern 方法进行操作。